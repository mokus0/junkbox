{-# LANGUAGE 
        StandaloneDeriving,
        FlexibleContexts,
        UndecidableInstances,
        RecordWildCards
        
  #-}
module NR.Ch4.S6 where

import NR.Ch5.S1

import Control.Arrow
import Control.Monad.Loops
import Control.Monad.ST
import Data.STRef
import qualified Data.Vector as V
import qualified Data.Vector.Generic as GV
import qualified Data.Vector.Generic.Mutable as MV
import Math.Legendre

-- |returns the integral of the function between the 2 points, by ten-point
-- Gauss-Legendre integration.  The function is evaluated exactly 10 times
-- at interior points in the range of integration.
--
-- Equivalent to a GaussQ generated by gauleg using x1 = -1, x2 = 1 and n=10.
qgaus func a b = xr * go xs ws 0
    where
        xs = [0.1488743389816312,0.4333953941292472,0.6794095682990244,0.8650633666889845,0.9739065285171717]
        ws = [0.2955242247147529,0.2692667193099963,0.2190863625159821,0.1494513491505806,0.0666713443086881]
        xm = 0.5*(b+a);
        xr = 0.5*(b-a);
        
        go [] [] s          = s
        go (x:xs) (w:ws) s  = go xs ws (s + w * (func (xm+dx) + func (xm-dx)))
                where dx = xr * x

-- |Range, weights and abscissas for gaussian quadrature.
data GaussQ v a = GaussQ 
    { gaussQRange :: !(a, a)
    , gaussQTable :: !(v (a, a))
    }

deriving instance (Eq   a, Eq   (v (a,a))) => Eq   (GaussQ v a)
deriving instance (Show a, Show (v (a,a))) => Show (GaussQ v a)

-- |Apply a Gaussian quadrature rule to a function.  The endpoints of integration
-- are a property of the rule - typically, they were supplied to the function
-- (such as 'gauleg' below) that computed the parameters for the rule.
integrate GaussQ{..} f = sum [w * f x | (x, w) <- GV.toList gaussQTable]

-- |Apply a Gaussian quadrature rule to a function, using user-specified 
-- endpoints of integration which may differ from those for which the
-- quadrature rule was originally defined.
integrateRange qRule f a0 a1
    | x0 == a0 && x1 == a1  = integrate qRule f
    | otherwise             = integrate qRule f'
    where
        (x0, x1) = gaussQRange qRule
        scale  = (a1 - a0) / (x1 - x0)
        
        f' x = scale * f ((x - x0) * scale + a0)

-- |Given the lower and upper limits of integration, number of points n, and
-- desired accuracy eps, this routine returns a GaussQ quadrature rule containing
-- the abscissas and weights of the Gauss-Legendre n-point quadrature formula.
--
-- Typical values for eps are 1e-15 for Double, 1e-6 for Float.  The specified
-- eps will be approximately the accuracy of the integration method as well.
gauleg x1 x2 n eps = GaussQ (x1, x2) table
    where
        table = flip GV.map (legendreRoots n eps) $ \(z,dy) ->
            ( {- abscissa -}    xm + xl * z
            , {- weight   -}    2 * xl / ((1 - z*z)*dy*dy)
            ) where
                xm = 0.5*(x2+x1)
                xl = 0.5*(x2-x1)

-- |Zeroes and corresponding derivatives of the n'th Legendre polynomial.
legendreRoots n eps = GV.map (negate *** id) mRoots GV.++ GV.reverse (GV.take (n-m) mRoots)
    where
        -- the roots are symmetric in the interval so we only have to find 'm' of them.
        -- The rest are reflections.  Sign on dz should be reflected too when n is even,
        -- but it doesn't really matter since it is going to be squared anyway.
        m = (n + 1) `div` 2
        mRoots = GV.generate m z
        z i = improveRoot (z0 i)
        
        -- Initial guess for i'th root of the n'th Legendre polynomial
        z0 i = realToFrac $ cos (pi * (fromIntegral i + 0.75) / (fromIntegral n + 0.5))
        -- Improve estimate of a root by newton's method
        improveRoot z1
            | abs (z2-z1) <= eps    = (z2, dy)
            | otherwise             = improveRoot z2
            where
                (y, dy) = evalLegendreDeriv n z1
                z2 = z1 - y/dy
