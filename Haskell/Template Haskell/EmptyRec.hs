{-# LANGUAGE TemplateHaskell #-}
-- |silly experiment... given the name of a data constructor (or a
-- type constructor for a type with only one data constructor, or a
-- type synonym for such a type), construct an \"empty\" value of that
-- constructor, parameterized over a human-friendly name to be displayed
-- in the missing-field messages.
-- 
-- For example:
-- 
-- > emptyState :: String -> State s t
-- > emptyState = $(empty ''State)
-- >
-- > foo :: State Double ()
-- > foo = emptyState "foo"
-- 
-- then in GHCi:
-- > foo
-- *** Exception: foo does not define field "runStateT" of the constructor "StateT"
--  
module EmptyRec (empty) where

import Data.List
import Language.Haskell.TH

empty name = do
    thing <- reify name
    case thing of
        TyConI dec -> emptyType name dec Nothing
        DataConI _ _ dataType _ -> do
            TyConI dec <- reify dataType
            emptyType name dec (Just name)
        _ -> reject name

-- ugly... all this does is find a constructor, given the declaration of
-- the type that it's supposed to be found in, and an optional name of a
-- constructor to find.  If the constructor name is omitted, it will only
-- succeed if there is only one constructor of the specified type.
-- 
-- Also handles chasing down type synonyms.  Does so under the assumption
-- that the data constructor is always in the 'head' of the  type synonym
-- definition.  I think this is correct, but I have not  made any attempt
-- to prove it.  The basic intuition for this assumption is that the only
-- way it should be possible is if the head is a partially applied type
-- synonym, which is not allowed.
emptyType _ (NewtypeD _ _ _ con _)         Nothing       = emptyCon con
emptyType _ (NewtypeD _ typeName _ con _) (Just conName)
    | conName == nameOfCon con  = emptyCon con
    | otherwise                 = noSuchCon typeName conName
emptyType _    (DataD _ _ _ [con] _)        Nothing       = emptyCon con
emptyType name (DataD _ _ _ _ _)            Nothing       = tooManyCons name
emptyType _    (DataD _ typeName _ cons _) (Just conName) =
    case find (\con -> conName == nameOfCon con) cons of
        Just con -> emptyCon con
        Nothing  -> noSuchCon typeName conName
emptyType name (TySynD _ _ synType) mbConName = do
    TyConI dec <- reify (headOfType synType)
    emptyType name dec mbConName
emptyType name _ _ = reject name

-- once the originally given name is resolved to a specific constructor
-- and the definition of that constructor has been reified, 'emptyCon'
-- handles the different kinds of constructors, reducing them all to a
-- single call to 'mkConExpr'.
emptyCon (NormalC conName args) =
    mkConExpr conName args getFieldNumOrName
        where getFieldNumOrName _ n = Left n
emptyCon (RecC conName args) = 
    mkConExpr conName args getFieldNumOrName
        where getFieldNumOrName (fieldName, _, _) _ = Right fieldName
emptyCon (InfixC a0 conName a1) = emptyCon (NormalC conName [a0, a1])
emptyCon (ForallC _ _ con)      = emptyCon con

mkConExpr :: Name -> [a] -> (a -> Int -> Either Int Name) -> ExpQ
mkConExpr conName args getFieldNumOrName =
    lamE [varP paramName] . appsE $
            ( conE conName
            : [ mkFieldExpr conName (getFieldNumOrName arg n)
              | (arg, n) <- zip args [0..]
              ]
            )

mkFieldExpr :: Name -> Either Int Name -> ExpQ
mkFieldExpr conName fieldNumOrName = [| error ($(varE paramName) ++ msg) |]
    where 
        msg = unwords 
                [ " does not define field"
                , either show (show . nameBase) fieldNumOrName
                , "of the constructor"
                , show (nameBase conName)
                ]


-- various constants and utility functions

nameOfCon (NormalC  name _) = name
nameOfCon (RecC     name _) = name
nameOfCon (InfixC _ name _) = name
nameOfCon (ForallC _ _ con) = nameOfCon con

headOfType (ForallT _ _ ty) = headOfType ty
headOfType (VarT name)      = name
headOfType (ConT name)      = name
headOfType (TupleT n)       = tupleTypeName n
headOfType (ArrowT)         = ''(->)
headOfType (ListT)          = ''[]
headOfType (AppT ty _)      = headOfType ty
headOfType (SigT ty _)      = headOfType ty

-- name of the parameter of the lambda generated by mkConExpr
paramName = mkName "x"

reject name = fail ("Don't know how to create an empty " ++ show name)
noSuchCon typeName conName = fail $ unwords
    [ show typeName
    , "has no constructor named"
    , show conName
    , "- this error means 'empty' is broken!"
    ]
tooManyCons name = fail $ unwords
    [ show name
    , "has too many constructors; please be more specific"
    ]

